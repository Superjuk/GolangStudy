package main

import (
	"fmt"
	"runtime"
	"sort"
	"strconv"
	"sync"
	"time"
)

func ExecutePipeline(jobs ...job) {
	var chans []chan interface{}
	for i := 0; i < len(jobs); i++ {
		chans = append(chans, make(chan interface{}, 100))
	}

	dummy := make(chan interface{})

	chans = append(chans, dummy)

	jobs[0](dummy, chans[0])

	jobSlice := jobs[1:]

	//func(chans []chan interface{}, jobSlice ...job) {
LOOP:
	for {
		select {
		case num := <-chans[0]:
			chans[1] <- strconv.Itoa(num.(int))

			for i, job := range jobSlice {
				go job(chans[i+1], chans[i+2])
			}
			fmt.Println(num)
		default:
			chans[1] <- "the_end"
			break LOOP
		}
	}
	//}(chans, jobs[1:]...)

}

func SingleHash(in, out chan interface{}) {
	runtime.Gosched()
LOOP:
	for {
		select {
		case data := <-in:
			dataStr := data.(string)

			if dataStr == "the_end" {
				out <- "the_end"
				fmt.Println("the_end")
				break LOOP
			}

			wg := &sync.WaitGroup{}
			wg.Add(2)

			dataSl := make([]string, 2)

			go Crc32Worker(wg, DataSignerMd5(dataStr), dataSl[1:2])
			go Crc32Worker(wg, dataStr, dataSl[0:1])

			wg.Wait()

			out <- dataSl[0] + "~" + dataSl[1]
		}
	}
}

func MultiHash(in, out chan interface{}) {
LOOP:
	for data := range in {
		if data == "the_end" {
			out <- data
			break LOOP
		}

		wg := &sync.WaitGroup{}
		wg.Add(6)

		dataSl := make([]string, 6)

		for i := 0; i < 6; i++ {
			go Crc32Worker(wg, strconv.Itoa(i)+data.(string), dataSl[i:i+1])
		}

		wg.Wait()

		var longData string
		for _, str := range dataSl {
			longData += str
		}
		fmt.Println(longData)
		out <- longData
	}
}

func CombineResults(in, out chan interface{}) {
	var dataArr []string
LOOP:
	for data := range in {
		if data == "the_end" {
			sort.Strings(dataArr)
			var result string
			for i, res := range dataArr {
				result += res
				if i != len(dataArr)-1 {
					result += "_"
				}
			}
			out <- result
			break LOOP
		}

		dataArr = append(dataArr, data.(string))
		//sort.Strings(dataArr)
	}
}

//func EndProgram(wg *sync.WaitGroup, in chan interface{}) {
//	for {
//		select {
//		case result := <-in:
//			fmt.Println("\n", result, "\n")
//			wg.Done()
//		}
//	}
//}

func Crc32Worker(wg *sync.WaitGroup, data string, slice []string) {
	crc32 := DataSignerCrc32(data)
	slice[0] = crc32
	//fmt.Println(crc32)
	wg.Done()
}

func main() {
	inputData := []int{0, 1, 1, 2, 3, 5, 8}

	hashSignJobs := []job{
		job(func(in, out chan interface{}) {
			for _, fibNum := range inputData {
				out <- fibNum
			}
		}),
		job(SingleHash),
		job(MultiHash),
		job(CombineResults),
		job(func(in, out chan interface{}) {
			dataRaw := <-in
			data := dataRaw.(string)
			fmt.Println(data)
		}),
	}

	start := time.Now()

	ExecutePipeline(hashSignJobs...)

	end := time.Since(start)

	fmt.Println("Time =", end)

	fmt.Scanln()
	//	start := time.Now()

	//	wg := &sync.WaitGroup{}
	//	wg.Add(1)

	//	chan_out := make(chan interface{}, 1)
	//	chan_in := make(chan interface{}, 1)
	//	chan_out2 := make(chan interface{}, 1)
	//	chan_in2 := make(chan interface{}, 1)

	//	go EndProgram(wg, chan_in2)

	//	go SingleHash(chan_out, chan_in)
	//	go MultiHash(chan_in, chan_out2)
	//	go CombineResults(chan_out2, chan_in2)

	//	chan_out <- 0
	//	chan_out <- 1
	//	chan_out <- 2
	//	chan_out <- 3
	//	chan_out <- 4
	//	chan_out <- 5
	//	chan_out <- 6

	//	wg.Wait()
	//	stop := time.Now()
	//	fmt.Println("Time =", stop.Sub(start))
}
