package main

import (
	"fmt"
	"sort"
	"strconv"
	"sync"
)

func ExecutePipeline(jobs ...job) {

}

func SingleHash(in, out chan interface{}) {
	for data := range in {
		dataStr := strconv.Itoa(data.(int))

		wg := &sync.WaitGroup{}
		wg.Add(2)

		dataSl := make([]string, 2)

		//crcMd := DataSignerCrc32(DataSignerMd5(dataStr))
		go Crc32Worker(wg, DataSignerMd5(dataStr), dataSl[1:2])
		//crc32 := DataSignerCrc32(dataStr)
		go Crc32Worker(wg, dataStr, dataSl[0:1])

		wg.Wait()
		//fmt.Println(crc32 + "~" + crcMd)
		out <- dataSl[0] + "~" + dataSl[1]
	}
}

func MultiHash(in, out chan interface{}) {
	for data := range in {
		wg := &sync.WaitGroup{}
		wg.Add(6)

		dataSl := make([]string, 6)

		for i := 0; i < 6; i++ {
			go Crc32Worker(wg, strconv.Itoa(i)+data.(string), dataSl[i:i+1])
		}

		wg.Wait()

		var longData string
		for _, str := range dataSl {
			longData += str
		}
		fmt.Println(longData)
		out <- longData
	}
}

func CombineResults(in, out chan interface{}) {
	var dataArr []string
	for {
		select {
		case data := <-in:
			dataArr = append(dataArr, data.(string))
			sort.Strings(dataArr)
			var result string
			for i, res := range dataArr {
				result += res
				if i != len(dataArr)-1 {
					result += "_"
				}
			}
			fmt.Println("\n", result, "\n")
			out <- "success"
		}
	}
}

func EndProgram(wg *sync.WaitGroup, in chan interface{}) {
	for {
		select {
		case isEnd := <-in:
			if isEnd == "success" {
				//fmt.Println("End program status = ", isEnd.(string))
				wg.Done()
			}
		}
	}
}

func Crc32Worker(wg *sync.WaitGroup, data string, slice []string) {
	crc32 := DataSignerCrc32(data)
	slice[0] = crc32
	fmt.Println(crc32)
	wg.Done()
}

func main() {
	//	jobs := []job{
	//		func(in, out chan interface{}) {

	//			out <- 16
	//			out <- 20

	//		},
	//		func(in, out chan interface{}) {
	//			number := <-in
	//			number = number.(int) + 24
	//			//out <- number
	//			fmt.Println(number)
	//		},
	//	}

	//ExecutePipeline(jobs...)
	//in jobs
	wg := &sync.WaitGroup{}

	chan_out := make(chan interface{}, 1)
	chan_in := make(chan interface{}, 1)
	chan_out2 := make(chan interface{}, 1)
	chan_in2 := make(chan interface{}, 1)

	go EndProgram(wg, chan_in2)

	go SingleHash(chan_out, chan_in)
	go MultiHash(chan_in, chan_out2)
	go CombineResults(chan_out2, chan_in2)

	wg.Add(7)
	chan_out <- 0
	chan_out <- 1
	chan_out <- 2
	chan_out <- 3
	chan_out <- 4
	chan_out <- 5
	chan_out <- 6

	wg.Wait()
}
